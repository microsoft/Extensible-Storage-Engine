// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

// This file is generated by grbits.pl

namespace Microsoft
{
#if (ESENT)
namespace Windows
#else
namespace Exchange
#endif
{
namespace Isam
{

// JET_bit* appears defines in jet.h, we rename them slightly (dropping JET_bit) to
// avoid a preprocessor nightmare

// The compiler doesn't believe that 0x80000000 will fit in to a signed int, so we get
// a warning. Instead we'll use INT_MIN, which is the same bit value.
// Converting MJET_GRIT to be an unsigned enum is a nuisance, since CLR is much happier
// with signed numbers.
C_ASSERT( 0x80000000 == INT_MIN );

[Flags]
MSINTERNAL enum class MJET_GRBIT
{

    NoGrbit = 0,
    DBUtilSpaceInfoBasicCatalog = 0x00000001,
    DBUtilSpaceInfoSpaceTrees = 0x00000002,
    DBUtilSpaceInfoParentOfLeaf = 0x00000004,
    DBUtilSpaceInfoFullWalk = 0x00000008,
    DBUtilFullCategorization = 0x00000001,
    DBUtilOptionAllNodes = 0x00000001,
    DBUtilOptionKeyStats = 0x00000002,
    DBUtilOptionPageDump = 0x00000004,
    DBUtilOptionStats = 0x00000008,
    DBUtilOptionSuppressConsoleOutput = 0x00000010,
    DBUtilOptionIgnoreErrors = 0x00000020,
    DBUtilOptionVerify = 0x00000040,
    DBUtilOptionReportErrors = 0x00000080,
    DBUtilOptionDontRepair = 0x00000100,
    DBUtilOptionRepairAll = 0x00000200,
    DBUtilOptionRepairIndexes = 0x00000400,
    DBUtilOptionDontBuildIndexes = 0x00000800,
    DBUtilOptionSuppressLogo = 0x00008000,
    DBUtilOptionRepairCheckOnly = 0x00010000,
    DBUtilOptionDumpLVPageUsage = 0x00020000,
    DBUtilOptionDumpLogInfoCSV = 0x00040000,
    DBUtilOptionDumpLogPermitPatching = 0x00080000, // permit the log dumper to patch edb.jtx/log if necessary
    DBUtilOptionSkipMinLogChecksUpdateHeader = 0x00100000,
    DBUtilOptionDumpVerbose = 0x10000000,
    DBUtilOptionDumpVerboseLevel2 = 0x20000000,
    DBUtilOptionDumpLogSummary = 0x40000000,
    ConfigStoreReadControlInhibitRead = 0x1, // Will stop reading from the registry config store, and pause reading until flag is removed (this will stall some JET initialization APIs).
    ConfigStoreReadControlDisableAll = 0x2, // Simply disables the registry config store from being read or used.
    ConfigStoreReadControlDisableSetParamRead = 0x4, // If ESE should not read the config data at the time we set the JET_paramConfigStoreSpec via JetSetSystemParameter().
    ConfigStoreReadControlDisableGlobalInitRead = 0x8, // If ESE should not read the config data at the time of global initialization / when ESE creates the very first instance.
    ConfigStoreReadControlDisableInstInitRead = 0x10, // If ESE should not read the config data at the time we initialize the instance.
    ConfigStoreReadControlDisableLiveRead = 0x20, // [Reserved for future usage at some point] If ESE should not read / update the values live.
    ConfigStoreReadControlDefault = 0x0, // Use default ESE behavior.
    ConfigStorePopulateControlOff = 0x00,
    ConfigStorePopulateControlOn = 0x01,
    DatabaseScanBatchStart = 0x00000010, // Starts a single-pass Database Maintenance thread.
    DatabaseScanBatchStop = 0x00000020, // Stops the Database Maintenance thread and frees any resources associated with it.
    DatabaseScanZeroPages = 0x00000040, // DEPRECATED
    DatabaseScanBatchStartContinuous = 0x00000080, // Starts a continuously-running Database Maintenance thread. pcSecondsMax, cmsecSleep and pfnCallback API parameters are not honored (system parameters should be used to fine-tune DBM).
    DefragmentBatchStart = 0x00000001,
    DefragmentBatchStop = 0x00000002,
    DefragmentAvailSpaceTreesOnly = 0x00000040, // only defrag AvailExt trees
    DefragmentNoPartialMerges = 0x00000080, // don't do partial merges during OLD
    DefragmentBTree = 0x00000100, // defrag one B-Tree
    DefragmentBTreeBatch = 0x00000200, // specifies options pertain to OLD2 / B-Tree defrag, such as JET_bitDefragmentBatchStart
    Old2Start = 0x00000001, // defrag action start (testing only)
    Old2Suspend = 0x00000002, // defrag action suspend (testing only)
    Old2Resume = 0x00000004, // defrag action resume (testing only)
    Old2End = 0x00000008, // defrag action end (testing only)
    CIMCommitted = 0x00000001,
    CIMDirty = 0x00000002,
    AggregateTransaction = 0x00000008,
    TableInfoUpdatable = 0x00000001,
    TableInfoBookmark = 0x00000002,
    TableInfoRollback = 0x00000004,
    ObjectSystem = INT_MIN, // Internal use only
    ObjectTableFixedDDL = 0x40000000, // Table's DDL is fixed
    ObjectTableTemplate = 0x20000000, // Table's DDL is inheritable (implies FixedDDL)
    ObjectTableDerived = 0x10000000, // Table's DDL is inherited from a template table
    ObjectTableNoFixedVarColumnsInDerivedTables = 0x04000000, // used in conjunction with JET_bitObjectTableTemplate
    DurableCommitCallbackLogUnavailable = 0x00000001, // Passed back to durable commit callback to let it know that log is down (and all pending commits will not be flushed to disk)
    IOSessTraceReads = 0x01,
    IOSessTraceWrites = 0x02,
    IOSessTraceHDD = 0x04,
    IOSessTraceSSD = 0x08,
    ESE98FileNames = 0x00000001, // Preserve the .log and .chk extension for compatibility reasons (i.e. Exchange)
    EightDotThreeSoftCompat = 0x00000002, // Preserve the 8.3 naming syntax for as long as possible. (this should not be changed, w/o ensuring there are no log files)
    HungIOEvent = 0x00000001, // Log event when an IO appears to be hung for over the IO threshold.
    HungIOCancel = 0x00000002, // Cancel an IO when an IO appears to be hung for over 2 x the IO threshhold.
    HungIODebug = 0x00000004, // Crash the process when an IO appears to be hung for over 3 x the IO threshhold.
    HungIOEnforce = 0x00000008, // Crash the process when an IO appears to be hung for over 3 x the IO threshhold.
    HungIOTimeout = 0x00000010, // Failure item when an IO appears to be hung for over 4 x the IO threshhold (considered timed out).
    PersistedLostFlushDetectionEnabled = 0x00000001, // Enables persisted lost flush detection.
    PersistedLostFlushDetectionCreateNew = 0x00000002, // If set, the persisted flush map is re-created on every database attachment.
    PersistedLostFlushDetectionFailOnRuntimeOnly = 0x00000004, // If set, lost flush errors are only returned if the flush state was set at runtime.
    ShrinkDatabaseOff = 0x0,
    ShrinkDatabaseOn = 0x1, // Uses the file system's Sparse Files feature to release space in the middle of a file.
    ShrinkDatabaseRealtime = 0x2, // Attempts to reclaim space back to the file system after freeing significant amounts of data (when space is marked as Available to the Root space tree).
    ShrinkDatabasePeriodically = 0x8000, // Periodically try to trim the database.
    ShrinkDatabaseTrim = 0x1, // DEPRECATED: Deprecated value for JET_bitShrinkDatabaseOn; Will be removed!
    ReplayReplicatedLogFiles = 0x00000001, // OBSOLETE and UNSUPPORTED, current log shipping implementations use JET_bitRecoveryWithoutUndo.
    ReplayIgnoreMissingDB = 0x00000004, // Ignore missing databases during recovery. This is a very dangerous option and may irrevocably produce an inconsistent database if improperly used. Normal ESE usage does not typically require this dangerous option.
    RecoveryWithoutUndo = 0x00000008, // perform recovery, but halt at the Undo phase
    TruncateLogsAfterRecovery = 0x00000010, // on successful soft recovery, truncate log files
    ReplayMissingMapEntryDB = 0x00000020, // missing database map entry default to same location
    LogStreamMustExist = 0x00000040, // transaction logs must exist in the logfile directory (ie. cannot auto-start a new log stream)
    ReplayIgnoreLostLogs = 0x00000080, // ignore logs lost from the end of the log stream
    AllowMissingCurrentLog = 0x00000100, // this allows JetInitX() to ignore the fact that we are missing edb.jtx|log and edbtmp.jtx|log
    AllowSoftRecoveryOnBackup = 0x00000200, // this allows JetInitX() to perform soft recovery on a backed up database, essentially implementing hard recovery via JetInitX()
    SkipLostLogsEvent = 0x00000400, // this supresses the event for lost committed logs for HA incremental reseed V1
    ExternalRecoveryControl = 0x00000800, // this for absolute control of the recovery process via invoking a callback to be made for all significant state decisions during recovery
    KeepDbAttachedAtEndOfRecovery = 0x00001000, // this allows db to remain attached at the end of recovery (for faster transition to running state)
    ReplayIgnoreLogRecordsBeforeMinRequiredLog = 0x00002000, // Ignore log records before the min required log for an attached database.
    ReplayInferCheckpointFromRstmapDbs = 0x00004000, // When no checkpoint file is present use databases in restore-map to infer checkpoint instead of starting from oldest log.
    RestoreMapIgnoreWhenMissing = 0x00000001, // Ignore missing database when replaying an attach or create database during recovery
    RestoreMapFailWhenMissing = 0x00000002, // Fail early on a missing database when replaying an attach or create database during recovery
    RestoreMapOverwriteOnCreate = 0x00000004, // Overwrite existing database when replaying a create database during recovery
    TermComplete = 0x00000001,
    TermAbrupt = 0x00000002,
    TermStopBackup = 0x00000004,
    TermDirty = 0x00000008,
    IdleFlushBuffers = 0x00000001,
    IdleCompact = 0x00000002,
    IdleStatus = 0x00000004,
    IdleVersionStoreTest = 0x00000008, // INTERNAL USE ONLY. call version store consistency check
    IdleCompactAsync = 0x00000010,
    IdleAvailBuffersStatus = 0x00000020, // Returns JET_wrnIdleFull when database cache available buffers is less than the JET_paramStartFlushThreshold setting.
    IdleWaitForAsyncActivity = 0x00000040, // Waits for all async activity to quiesce. Returns JET_wrnRemainingVersions if there are still pending version store buckets.
    ForceSessionClosed = 0x00000001,
    DbReadOnly = 0x00000001,
    DbExclusive = 0x00000002, // multiple opens allowed
    DbSingleExclusive = 0x00000002, // NOT CURRENTLY IMPLEMENTED - currently maps to JET_bitDbExclusive
    DbDeleteCorruptIndexes = 0x00000010, // delete indexes possibly corrupted by NT version upgrade
    DbRebuildCorruptIndexes = 0x00000020, // NOT CURRENTLY IMPLEMENTED - recreate indexes possibly corrupted by NT version upgrade
    DbDeleteUnicodeIndexes = 0x00000400, // delete all indexes with unicode columns
    DbUpgrade = 0x00000200,
    DbEnableBackgroundMaintenance = 0x00000800, // the database engine will initiate automatic background database maintenance
    DbPurgeCacheOnAttach = 0x00001000, // used to ensure any kept alive cache is purged for this DB before attach
    ForceDetach = 0x00000001,
    DbRecoveryOff = 0x00000008, // disable logging/recovery for this database
    DbVersioningOff = 0x00000040, // INTERNAL USE ONLY
    DbShadowingOff = 0x00000080, // disable catalog shadowing
    DbCreateStreamingFile = 0x00000100, // create streaming file with same name as db
    DbOverwriteExisting = 0x00000200, // overwrite existing database with same name
    BackupIncremental = 0x00000001,
    KeepOldLogs = 0x00000002,
    BackupAtomic = 0x00000004,
    BackupFullWithAllLogs = 0x00000008,
    BackupSnapshot = 0x00000010,
    BackupSurrogate = 0x00000020,
    InternalCopy = 0x00000040,
    BackupEndNormal = 0x0001,
    BackupEndAbort = 0x0002,
    BackupTruncateDone = 0x0100,
    BackupNoDbHeaderUpdate = 0x0200,
    TableCreateFixedDDL = 0x00000001, // DDL is fixed
    TableCreateTemplateTable = 0x00000002, // DDL is inheritable (implies FixedDDL)
    TableCreateNoFixedVarColumnsInDerivedTables = 0x00000004,
    TableCreateImmutableStructure = 0x00000008, // Do not write to the input structures. Additionally, do not return any auto-opened tableid.
    TableCreateSystemTable = INT_MIN, // INTERNAL USE ONLY
    ColumnFixed = 0x00000001,
    ColumnTagged = 0x00000002,
    ColumnNotNULL = 0x00000004,
    ColumnVersion = 0x00000008,
    ColumnAutoincrement = 0x00000010,
    ColumnUpdatable = 0x00000020, // JetGetColumnInfo only
    ColumnTTKey = 0x00000040, // JetOpenTempTable only
    ColumnTTDescending = 0x00000080, // JetOpenTempTable only
    ColumnMultiValued = 0x00000400,
    ColumnEscrowUpdate = 0x00000800, // escrow updated, supported coltyps are long and longlong
    ColumnUnversioned = 0x00001000, // for add column only - add column unversioned
    ColumnMaybeNull = 0x00002000, // for retrieve column info of outer join where no match from the inner table
    ColumnFinalize = 0x00004000, // DEPRECATED / Not Fully Implemented: use JET_bitColumnDeleteOnZero instead.
    ColumnUserDefinedDefault = 0x00008000, // default value from a user-provided callback
    ColumnRenameConvertToPrimaryIndexPlaceholder = 0x00010000, // FOR JetRenameColumn() ONLY: rename and convert to primary index placeholder (ie. no longer part of primary index ecxept as a placeholder)
    ColumnDeleteOnZero = 0x00020000, // When the escrow-update column reaches a value of zero (after all versions are resolve), the record will be deleted. A common use for a column that can be finalized is to use it as a reference count field, and when the field reaches zero the record gets deleted. A Delete-on-zero column must be an escrow update / JET_bitColumnEscrowUpdate column. JET_bitColumnDeleteOnZero cannot be used with JET_bitColumnFinalize. JET_bitColumnDeleteOnZero cannot be used with user defined default columns.
    ColumnVariable = 0x00040000, // make column a variable length column
    ColumnCompressed = 0x00080000, // data in the column can be compressed
    ColumnEncrypted = 0x00100000, // data in the column is encrypted
    DeleteColumnIgnoreTemplateColumns = 0x00000001, // for derived tables, don't bother looking in template columns
    MoveFirst = 0x00000000,
    MoveBeforeFirst = 0x00000001, // unsupported -- DO NOT USE
    NoMove = 0x00000002,
    NewKey = 0x00000001,
    StrLimit = 0x00000002,
    SubStrLimit = 0x00000004,
    NormalizedKey = 0x00000008,
    KeyDataZeroLength = 0x00000010,
    KeyOverridePrimaryIndexPlaceholder = 0x00000020,
    FullColumnStartLimit = 0x00000100,
    FullColumnEndLimit = 0x00000200,
    PartialColumnStartLimit = 0x00000400,
    PartialColumnEndLimit = 0x00000800,
    RangeInclusive = 0x00000001,
    RangeUpperLimit = 0x00000002,
    RangeInstantDuration = 0x00000004,
    RangeRemove = 0x00000008,
    ReadLock = 0x00000001,
    WriteLock = 0x00000002,
    MoveKeyNE = 0x00000001,
    SeekEQ = 0x00000001,
    SeekLT = 0x00000002,
    SeekLE = 0x00000004,
    SeekGE = 0x00000008,
    SeekGT = 0x00000010,
    SetIndexRange = 0x00000020,
    CheckUniqueness = 0x00000040, // to be used with JET_bitSeekEQ only, returns JET_wrnUniqueKey if seek lands on a key which has no dupes
    BookmarkPermitVirtualCurrency = 0x00000001, // place cursor on relative position in index if specified bookmark no longer exists
    IndexColumnMustBeNull = 0x00000001,
    IndexColumnMustBeNonNull = 0x00000002,
    RecordInIndex = 0x00000001,
    RecordNotInIndex = 0x00000002,
    IndexUnique = 0x00000001,
    IndexPrimary = 0x00000002,
    IndexDisallowNull = 0x00000004,
    IndexIgnoreNull = 0x00000008,
    IndexClustered40 = 0x00000010, // for backward compatibility
    IndexIgnoreAnyNull = 0x00000020,
    IndexIgnoreFirstNull = 0x00000040,
    IndexLazyFlush = 0x00000080,
    IndexEmpty = 0x00000100, // don't attempt to build index, because all entries would evaluate to NULL (MUST also specify JET_bitIgnoreAnyNull)
    IndexUnversioned = 0x00000200,
    IndexSortNullsHigh = 0x00000400, // NULL sorts after data for all columns in the index
    IndexUnicode = 0x00000800, // LCID field of JET_INDEXCREATE actually points to a JET_UNICODEINDEX struct to allow user-defined LCMapString() flags
    IndexTuples = 0x00001000, // index on substring tuples (text columns only)
    IndexTupleLimits = 0x00002000, // cbVarSegMac field of JET_INDEXCREATE actually points to a JET_TUPLELIMITS struct to allow custom tuple index limits (implies JET_bitIndexTuples)
    IndexCrossProduct = 0x00004000, // index over multiple multi-valued columns has full cross product
    IndexKeyMost = 0x00008000, // custom index key size set instead of default of 255 bytes
    IndexDisallowTruncation = 0x00010000, // fail update rather than truncate index keys
    IndexNestedTable = 0x00020000, // index over multiple multi-valued columns but only with values of same itagSequence
    IndexDotNetGuid = 0x00040000, // index over GUID column according to .Net GUID sort order
    IndexImmutableStructure = 0x00080000, // Do not write to the input structures during a JetCreateIndexN call.
    KeyAscending = 0x00000000,
    KeyDescending = 0x00000001,
    TableDenyWrite = 0x00000001,
    TableDenyRead = 0x00000002,
    TableReadOnly = 0x00000004,
    TableUpdatable = 0x00000008,
    TablePermitDDL = 0x00000010, // override table flagged as FixedDDL (must be used with DenyRead)
    TableNoCache = 0x00000020, // don't cache the pages for this table
    TablePreread = 0x00000040, // assume the table is probably not in the buffer cache
    TableOpportuneRead = 0x00000080, // attempt to opportunely read physically adjacent leaf pages using larger physical IOs
    TableAllowOutOfDate = 0x00000100, // allow opening with indexes using out-of-date (but valid) sort versions
    AllowPgnoFDPLastSetTime = 0x00000200, // allow changing pgnofdp last set time in catalog while opening the table
    TableSequential = 0x00008000, // assume the table will be scanned sequentially
    TableTryPurgeOnClose = 0x01000000, // INTERNAL USE ONLY: attempt to cleanup resources when table is closed
    TableAllowSensitiveOperation = 0x08000000, // INTERNAL USE ONLY
    TableDelete = 0x10000000, // INTERNAL USE ONLY
    TableCreate = 0x20000000, // INTERNAL USE ONLY
    TableClassMask = 0x001F0000, // table stats class mask
    TableClassNone = 0x00000000, // table belongs to no stats class (default)
    TableClass1 = 0x00010000, // table belongs to stats class 1
    TableClass2 = 0x00020000, // table belongs to stats class 2
    TableClass3 = 0x00030000, // table belongs to stats class 3
    TableClass4 = 0x00040000, // table belongs to stats class 4
    TableClass5 = 0x00050000, // table belongs to stats class 5
    TableClass6 = 0x00060000, // table belongs to stats class 6
    TableClass7 = 0x00070000, // table belongs to stats class 7
    TableClass8 = 0x00080000, // table belongs to stats class 8
    TableClass9 = 0x00090000, // table belongs to stats class 9
    TableClass10 = 0x000A0000, // table belongs to stats class 10
    TableClass11 = 0x000B0000, // table belongs to stats class 11
    TableClass12 = 0x000C0000, // table belongs to stats class 12
    TableClass13 = 0x000D0000, // table belongs to stats class 13
    TableClass14 = 0x000E0000, // table belongs to stats class 14
    TableClass15 = 0x000F0000, // table belongs to stats class 15
    TableClass16 = 0x00100000, // table belongs to stats class 16
    TableClass17 = 0x00110000, // table belongs to stats class 17
    TableClass18 = 0x00120000, // table belongs to stats class 18
    TableClass19 = 0x00130000, // table belongs to stats class 19
    TableClass20 = 0x00140000, // table belongs to stats class 20
    TableClass21 = 0x00150000, // table belongs to stats class 21
    TableClass22 = 0x00160000, // table belongs to stats class 22
    TableClass23 = 0x00170000, // table belongs to stats class 23
    TableClass24 = 0x00180000, // table belongs to stats class 24
    TableClass25 = 0x00190000, // table belongs to stats class 25
    TableClass26 = 0x001A0000, // table belongs to stats class 26
    TableClass27 = 0x001B0000, // table belongs to stats class 27
    TableClass28 = 0x001C0000, // table belongs to stats class 28
    TableClass29 = 0x001D0000, // table belongs to stats class 29
    TableClass30 = 0x001E0000, // table belongs to stats class 30
    TableClass31 = 0x001F0000, // table belongs to stats class 31
    LSReset = 0x00000001, // reset LS value
    LSCursor = 0x00000002, // set/retrieve LS of table cursor
    LSTable = 0x00000004, // set/retrieve LS of table
    PrereadForward = 0x00000001, // Hint that the sequential traversal will be in the forward direction
    PrereadBackward = 0x00000002, // Hint that the sequential traversal will be in the backward direction
    PrereadFirstPage = 0x00000004, // Only first page of long values should be preread
    PrereadNormalizedKey = 0x00000008, // Normalized key/bookmark provided instead of column value
    TTIndexed = 0x00000001, // Allow seek
    TTUnique = 0x00000002, // Remove duplicates
    TTUpdatable = 0x00000004, // Allow updates
    TTScrollable = 0x00000008, // Allow backwards scrolling
    TTSortNullsHigh = 0x00000010, // NULL sorts after data for all columns in the index
    TTForceMaterialization = 0x00000020, // Forces temp. table to be materialized into a btree (allows for duplicate detection)
    TTForwardOnly = 0x00000040, // Prevents temp. table from being materialized into a btree (and enables duplicate keys)
    TTIntrinsicLVsOnly = 0x00000080, // permit only intrinsic LV's (so materialisation is not required simply because a TT has an LV column)
    TTDotNetGuid = 0x00000100, // sort all JET_coltypGUID columns according to .Net Guid sort order
    SetAppendLV = 0x00000001,
    SetOverwriteLV = 0x00000004, // overwrite JET_coltypLong* byte range
    SetSizeLV = 0x00000008, // set JET_coltypLong* size
    SetZeroLength = 0x00000020,
    SetSeparateLV = 0x00000040, // force LV separation
    SetUniqueMultiValues = 0x00000080, // prevent duplicate multi-values
    SetUniqueNormalizedMultiValues = 0x00000100, // prevent duplicate multi-values, normalizing all data before performing comparisons
    SetRevertToDefaultValue = 0x00000200, // if setting last tagged instance to NULL, revert to default value instead if one exists
    SetIntrinsicLV = 0x00000400, // store whole LV in record without bursting or return an error
    SetUncompressed = 0x00010000, // don't attempt compression when storing the data
    SetCompressed = 0x00020000, // attempt compression when storing the data
    SetContiguousLV = 0x00040000, // Allocates the long-value across contiguous pages (at potentialy space saving costs) for better IO behavior. Valid only with JET_bitSetSeparateLV. Invalid (or not implemented) with certain long-value operations such as replace, and certain column options such as compression. Use across many varying LVs sizes may cause space fragmentation / allocation issues.
    SpaceHintsUtilizeParentSpace = 0x00000001, // This changes the internal allocation policy to get space hierarchically from a B-Tree's immediate parent.
    CreateHintAppendSequential = 0x00000002, // This bit will enable Append split behavior to grow according to the growth dynamics of the table (set by cbMinExtent, ulGrowth, cbMaxExtent).
    CreateHintHotpointSequential = 0x00000004, // This bit will enable Hotpoint split behavior to grow according to the growth dynamics of the table (set by cbMinExtent, ulGrowth, cbMaxExtent).
    RetrieveHintReserve1 = 0x00000008, // Reserved and ignored
    RetrieveHintTableScanForward = 0x00000010, // By setting this the client indicates that forward sequential scan is the predominant usage pattern of this table (causing B+ Tree defrag to be auto-triggered to clean it up if fragmented).
    RetrieveHintTableScanBackward = 0x00000020, // By setting this the client indicates that backwards sequential scan is the predominant usage pattern of this table (causing B+ Tree defrag to be auto-triggered to clean it up if fragmented).
    RetrieveHintReserve2 = 0x00000040, // Reserved and ignored
    RetrieveHintReserve3 = 0x00000080, // Reserved and ignored
    DeleteHintTableSequential = 0x00000100, // This means that the application expects this table to be cleaned up in-order sequentially (from lowest key to highest key)
    SpaceHintsUtilizeExactExtents = 0x00000200, // This changes the internal allocation policy to always allocate extents of the size requested by the space hints.
    UpdateCheckESE97Compatibility = 0x00000001, // check whether record fits if represented in ESE97 database format
    UpdateNoVersion = 0x00000002, // do not create rollback or versioning information for update
    EscrowNoRollback = 0x0001,
    RetrieveCopy = 0x00000001,
    RetrieveFromIndex = 0x00000002,
    RetrieveFromPrimaryBookmark = 0x00000004,
    RetrieveTag = 0x00000008,
    RetrieveNull = 0x00000010, // for columnid 0 only
    RetrieveIgnoreDefault = 0x00000020, // for columnid 0 only
    RetrieveLongId = 0x00000040,
    RetrieveLongValueRefCount = 0x00000080, // for testing use only
    RetrieveTuple = 0x00000800, // retrieve tuple fragment from index
    RetrievePageNumber = 0x00001000, // page number list for column
    RetrieveCopyIntrinsic = 0x00002000, // retrieves size of data that can be added to a record before offloading LONG columns.  Fixed sized columns return 0 or column size.
    RetrievePrereadOnly = 0x00004000,
    RetrievePrereadMany = 0x00008000,
    RetrievePhysicalSize = 0x00010000, // retrieves compressed size only in cbActual; no data is retrieved
    RetrieveAsRefIfNotInRecord = 0x00020000, // Retrieves the column value as a reference if it is not in the record.
    ZeroLength = 0x00000001,
    EnumerateLocal = 0x00010000,
    EnumeratePresenceOnly = 0x00020000,
    EnumerateTaggedOnly = 0x00040000,
    EnumerateCompressOutput = 0x00080000,
    EnumerateIgnoreUserDefinedDefault = 0x00100000,
    EnumerateInRecordOnly = 0x00200000,
    EnumerateAsRefIfNotInRecord = 0x00400000, // Retrieves the column value as a reference if it is not in the record.
    StreamForward = 0x00000001, // Stream records in ascending key order.
    StreamBackward = 0x00000002, // Stream records in descending key order.
    StreamColumnReferences = 0x00000004, // Stream column values as column references when not in the record.
    RecordSizeInCopyBuffer = 0x00000001, // use record in copy buffer
    RecordSizeRunningTotal = 0x00000002, // increment totals in output buffer instead of setting them
    RecordSizeLocal = 0x00000004, // ignore Long Values (and other data otherwise not in the same page as the record)
    RecordSizeIncludeDefaultValues = 0x00000008, // compute size of default-valued columns (CURRENTLY UNSUPPORTED)
    RecordSizeSecondaryIndexKeyOnly = 0x00000010, // compute size of secondary index key instead of record size (CURRENTLY UNSUPPORTED)
    RecordSizeIntrinsicPhysicalOnly = 0x00000020, // only get physical size for intrinsic columns (cheaper)
    RecordSizeExtrinsicLogicalOnly = 0x00000040, // only get logical size for extrinsic columns (cheaper)
    TransactionReadOnly = 0x00000001, // transaction will not modify the database
    DistributedTransaction = 0x00000002, // transaction will require two-phase commit
    CommitLazyFlush = 0x00000001, // lazy flush log buffers.
    WaitLastLevel0Commit = 0x00000002, // wait for last level 0 commit record flushed
    WaitAllLevel0Commit = 0x00000008, // wait for all level 0 commits to be flushed
    ForceNewLog = 0x00000010,
    CommitRedoCallback = 0x00000020,
    CommitFlush_OLD = 0x00000001, // commit and flush page buffers.
    CommitLazyFlush_OLD = 0x00000004, // lazy flush log buffers.
    WaitLastLevel0Commit_OLD = 0x00000010, // wait for last level 0 commit record flushed
    RollbackAll = 0x00000001,
    RollbackRedoCallback = 0x00000020,
    IncrementalSnapshot = 0x00000001, // bit 0: full (0) or incremental (1) snapshot
    CopySnapshot = 0x00000002, // bit 1: normal (0) or copy (1) snapshot
    ContinueAfterThaw = 0x00000004, // bit 2: end on thaw (0) or wait for [truncate +] end snapshot
    ExplicitPrepare = 0x00000008, // bit 3: all instaces prepared by default (0) or no instance prepared by default (1)
    AllDatabasesSnapshot = 0x00000001, // bit 0: there are detached dbs in the instance (i.e. can't truncate logs)
    AbortSnapshot = 0x00000001, // snapshot process failed
    ShadowLogEmitFirstCall = 0x00000001, // the very first emit has only this bit set, log data will likely follow next
    ShadowLogEmitLastCall = 0x00000002, // the very last emit has only this bit set, no more log data will follow
    ShadowLogEmitCancel = 0x00000004, // future: user requested this be cancelled via resetting the JET_param to NULL
    ShadowLogEmitDataBuffers = 0x00000008, // callback emits some portion of the log buffer and position in log
    ShadowLogEmitLogComplete = 0x00000010, // callback emits signal that the current log file is completed
    DeleteAllExistingLogs = 0x00000001, // Delete all the existing log files at the end of revert.
    NonRevertableTableDelete = 0x00000001, // If set, doesn't capture page preimages to allow for reverting the table to a state where it still existed using RBS.
    RevertableTableDeleteIfTooSoon = 0x00000002, // If set, we will do a revertable table even if NonRevertableTableDelete flag is passed provided NonRevertable delete is failing due to JET_errRBSDeleteTableTooSoon.
    PageInfoNoStructureChecksum = 0x00000001, // Do not compute structure checksum
    TestUninitShrunkPageImage = 0x00000001,
    PatchingCorruptPage = 0x00000002,
    EndDatabaseIncrementalReseedCancel = 0x00000001, // Stop an incremental reseed operation prematurely for any (failing) reason.  Database will be left in inconsistent JET_dbstateIncrementalReseedInProgress state.
    BeginDatabaseIncrementalReseedPatchRBS = 0x00000001, // Try to patch RBS file as part of increseed. If this flag is not passed, we will lose the RBS files and the ability to revert back to the past.
    CompactStats = 0x00000020, // Dump off-line compaction stats (only when progress meter also specified)
    CompactRepair = 0x00000040, // Don't preread and ignore duplicate keys
    CompactPreserveOriginal = 0x00000100, // Preserve original database
    ResizeDatabaseOnlyGrow = 0x00000001, // Only grow the database. If the resize call would shrink the database, do nothing.
    ResizeDatabaseOnlyShrink = 0x00000002, // Only shrink the database. If the resize call would grow the database, do nothing. The file may end up smaller than requested.
    StopServiceAll = 0x00000000, // Stops all ESE services for the specified instance.
    StopServiceBackgroundUserTasks = 0x00000002, // Stops restartable client specificed background maintenance tasks (B+ Tree Defrag for example).
    StopServiceQuiesceCaches = 0x00000004, // Quiesces all dirty caches to disk. Asynchronous. Cancellable.
    StopServiceResume = INT_MIN, // Resumes previously issued StopService operations, i.e. "restarts service".  Can be combined with above grbits to Resume specific services, or with JET_bitStopServiceAll to Resume all previously stopped services.
    StopServiceStopAndEmitLog = 0x00000008, // Stop any further logging and emit last chunk of log.
    StageTestEnvLocalMode = 0x04,
    StageTestEnvAlphaMode = 0x10,
    StageTestEnvBetaMode = 0x40,
    StageSelfhostLocalMode = 0x0400,
    StageSelfhostAlphaMode = 0x1000,
    StageSelfhostBetaMode = 0x4000,
    StageProdLocalMode = 0x040000,
    StageProdAlphaMode = 0x100000,
    StageProdBetaMode = 0x400000,
    ShrinkDatabaseEofOnAttach = 0x00000001, // Resizes the database file during its attachment.
    ShrinkDatabaseFullCategorizationOnAttach = 0x00000002, // Enables full space categorization when shrinking the database
    ShrinkDatabaseDontMoveRootsOnAttach = 0x00000004, // Disable root moves when shrinking the database
    ShrinkDatabaseDontTruncateLeakedPagesOnAttach = 0x00000008, // Disable truncating leaked pages when shrinking the database
    ShrinkDatabaseDontTruncateIndeterminatePagesOnAttach = 0x00000010, // Disable truncating indeterminate/uncategorized pages when
    DumpMinimum = 0x00000001,
    DumpMaximum = 0x00000002,
    DumpCacheMinimum = 0x00000004,
    DumpCacheMaximum = 0x00000008,
    DumpCacheIncludeDirtyPages = 0x00000010,
    DumpCacheIncludeCachedPages = 0x00000020,
    DumpCacheIncludeCorruptedPages = 0x00000040,
    DumpCacheNoDecommit = 0x00000080,
    DumpUnitTest = INT_MIN,
    InjectionProbabilityPct = 0x00000001, // default, with 100% ulProbability.
    InjectionProbabilityCount = 0x00000002, // one shot on nth (ulProbability) evaluation.
    InjectionProbabilityPermanent = 0x00000004, // same as one shot, but permanent after fire (must be OR'd with JET_bitInjectionProbabilityCount).
    InjectionProbabilityFailUntil = 0x00000008, // same as one shot, but fails until fire (must be OR'd with JET_bitInjectionProbabilityCount).
    InjectionProbabilitySuppress = 0x40000000, // removes injection temporarily
    InjectionProbabilityCleanup = INT_MIN, // removes injection entry for the ID.
    TestHookEvictDataByPgno = 0x00000001, // Specifies that we are evicting data from the database cache, specified by pgno.
    TestHookCorruptDatabaseFile = INT_MIN, // Use .CorruptDatabaseFile
    TestHookCorruptDatabasePageImage = 0x40000000, // Use .CorruptDatabasePageImage
    TestHookCorruptPageChksumRand = 0x00000001, // usable with ...CorruptDatabase*
    TestHookCorruptPageChksumSafe = 0x00000002, // usable with ...CorruptDatabase*
    TestHookCorruptPageSingleFld = 0x00000004, // usable with ...CorruptDatabase*
    TestHookCorruptPageRemoveNode = 0x00000008, // usable with ...CorruptDatabase*
    TestHookCorruptPageDbtimeDelta = 0x00000010, // usable with ...CorruptDatabase*
    TestHookCorruptNodePrefix = 0x00000020, // usable with ...CorruptDatabase*
    TestHookCorruptNodeSuffix = 0x00000040, // usable with ...CorruptDatabase*
    TestHookCorruptSizeLargerThanNode = 0x00010000, // adds a cb that is just larger than the node / line.cb size.
    TestHookCorruptSizeShortWrapSmall = 0x00020000, // adds 0x8000 to the cb.
    TestHookCorruptSizeShortWrapLarge = 0x00040000, // adds 0xF000 to the cb.
    TestHookCorruptLeaveChecksum = 0x01000000, // usable with ...CorruptDatabase*
    AlterDbFileHdrAddField = 0x1, // Makes it so the pbField (but only if cbField is 4 or 8 bytes) be interpreted as an long or long long.
};

}
}
}
