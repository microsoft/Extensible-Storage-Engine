// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

// This file is generated by grbits.pl

namespace Microsoft
{
#if (ESENT)
namespace Windows
#else
namespace Exchange
#endif
{
namespace Isam
{

// JET_bit* appears defines in jet.h, we rename them slightly (dropping JET_bit) to
// avoid a preprocessor nightmare

// The compiler doesn't believe that 0x80000000 will fit in to a signed int, so we get
// a warning. Instead we'll use INT_MIN, which is the same bit value.
// Converting MJET_GRIT to be an unsigned enum is a nuisance, since CLR is much happier
// with signed numbers.
C_ASSERT( 0x80000000 == INT_MIN );

[Flags]
MSINTERNAL enum class MJET_GRBIT
{

    NoGrbit = 0,
    DBUtilSpaceInfoBasicCatalog = 0x00000001,
    DBUtilSpaceInfoSpaceTrees = 0x00000002,
    DBUtilSpaceInfoParentOfLeaf = 0x00000004,
    DBUtilSpaceInfoFullWalk = 0x00000008,
    DBUtilFullCategorization = 0x00000001,
    DBUtilOptionAllNodes = 0x00000001,
    DBUtilOptionKeyStats = 0x00000002,
    DBUtilOptionPageDump = 0x00000004,
    DBUtilOptionStats = 0x00000008,
    DBUtilOptionSuppressConsoleOutput = 0x00000010,
    DBUtilOptionIgnoreErrors = 0x00000020,
    DBUtilOptionVerify = 0x00000040,
    DBUtilOptionReportErrors = 0x00000080,
    DBUtilOptionDontRepair = 0x00000100,
    DBUtilOptionRepairAll = 0x00000200,
    DBUtilOptionRepairIndexes = 0x00000400,
    DBUtilOptionDontBuildIndexes = 0x00000800,
    DBUtilOptionSuppressLogo = 0x00008000,
    DBUtilOptionRepairCheckOnly = 0x00010000,
    DBUtilOptionDumpLVPageUsage = 0x00020000,
    DBUtilOptionDumpLogInfoCSV = 0x00040000,
    DBUtilOptionDumpLogPermitPatching = 0x00080000, // permit the log dumper to patch edb.jtx/log if necessary
    DBUtilOptionSkipMinLogChecksUpdateHeader = 0x00100000,
    DBUtilOptionDumpVerbose = 0x10000000,
    DBUtilOptionDumpVerboseLevel2 = 0x20000000,
    DBUtilOptionDumpLogSummary = 0x40000000,
    ConfigStoreReadControlInhibitRead = 0x1, // Will stop reading from the registry config store, and pause reading until flag is removed (this will stall some JET initialization APIs).
    ConfigStoreReadControlDisableAll = 0x2, // Simply disables the registry config store from being read or used.
    ConfigStoreReadControlDisableSetParamRead = 0x4, // If ESE should not read the config data at the time we set the JET_paramConfigStoreSpec via JetSetSystemParameter().
    ConfigStoreReadControlDisableGlobalInitRead = 0x8, // If ESE should not read the config data at the time of global initialization / when ESE creates the very first instance.
    ConfigStoreReadControlDisableInstInitRead = 0x10, // If ESE should not read the config data at the time we initialize the instance.
    ConfigStoreReadControlDisableLiveRead = 0x20, // [Reserved for future usage at some point] If ESE should not read / update the values live.
    ConfigStoreReadControlDefault = 0x0, // Use default ESE behavior.
    ConfigStorePopulateControlOff = 0x00,
    ConfigStorePopulateControlOn = 0x01,
    DatabaseScanBatchStart = 0x00000010, // Starts a single-pass Database Maintenance thread.
    DatabaseScanBatchStop = 0x00000020, // Stops the Database Maintenance thread and frees any resources associated with it.
    DatabaseScanZeroPages = 0x00000040, // DEPRECATED
    DatabaseScanBatchStartContinuous = 0x00000080, // Starts a continuously-running Database Maintenance thread. pcSecondsMax, cmsecSleep and pfnCallback API parameters are not honored (system parameters should be used to fine-tune DBM).
    DefragmentBatchStart = 0x00000001,
    DefragmentBatchStop = 0x00000002,
    DefragmentAvailSpaceTreesOnly = 0x00000040, // only defrag AvailExt trees
    DefragmentNoPartialMerges = 0x00000080, // don't do partial merges during OLD
    DefragmentBTree = 0x00000100, // defrag one B-Tree
    DefragmentBTreeBatch = 0x00000200, // specifies options pertain to OLD2 / B-Tree defrag, such as JET_bitDefragmentBatchStart
    Old2Start = 0x00000001, // defrag action start (testing only)
    Old2Suspend = 0x00000002, // defrag action suspend (testing only)
    Old2Resume = 0x00000004, // defrag action resume (testing only)
    Old2End = 0x00000008, // defrag action end (testing only)
    CIMCommitted = 0x00000001,
    CIMDirty = 0x00000002,
    AggregateTransaction = 0x00000008,
    TableInfoUpdatable = 0x00000001,
    TableInfoBookmark = 0x00000002,
    TableInfoRollback = 0x00000004,
    ObjectSystem = INT_MIN, // Internal use only
    ObjectTableFixedDDL = 0x40000000, // Table's DDL is fixed
    ObjectTableTemplate = 0x20000000, // Table's DDL is inheritable (implies FixedDDL)
    ObjectTableDerived = 0x10000000, // Table's DDL is inherited from a template table
    ObjectTableNoFixedVarColumnsInDerivedTables = 0x04000000, // used in conjunction with JET_bitObjectTableTemplate
    DurableCommitCallbackLogUnavailable = 0x00000001, // Passed back to durable commit callback to let it know that log is down (and all pending commits will not be flushed to disk)
    IOSessTraceReads = 0x01,
    IOSessTraceWrites = 0x02,
    IOSessTraceHDD = 0x04,
    IOSessTraceSSD = 0x08,
    ESE98FileNames = 0x00000001, // Preserve the .log and .chk extension for compatibility reasons (i.e. Exchange)
    EightDotThreeSoftCompat = 0x00000002, // Preserve the 8.3 naming syntax for as long as possible. (this should not be changed, w/o ensuring there are no log files)
    HungIOEvent = 0x00000001, // Log event when an IO appears to be hung for over the IO threshold.
    HungIOCancel = 0x00000002, // Cancel an IO when an IO appears to be hung for over 2 x the IO threshhold.
    HungIODebug = 0x00000004, // Crash the process when an IO appears to be hung for over 3 x the IO threshhold.
    HungIOEnforce = 0x00000008, // Crash the process when an IO appears to be hung for over 3 x the IO threshhold.
    HungIOTimeout = 0x00000010, // Failure item when an IO appears to be hung for over 4 x the IO threshhold (considered timed out).
    PersistedLostFlushDetectionEnabled = 0x00000001, // Enables persisted lost flush detection.
    PersistedLostFlushDetectionCreateNew = 0x00000002, // If set, the persisted flush map is re-created on every database attachment.
    PersistedLostFlushDetectionFailOnRuntimeOnly = 0x00000004, // If set, lost flush errors are only returned if the flush state was set at runtime.
    ShrinkDatabaseOff = 0x0,
    ShrinkDatabaseOn = 0x1, // Uses the file system's Sparse Files feature to release space in the middle of a file.
    ShrinkDatabaseRealtime = 0x2, // Attempts to reclaim space back to the file system after freeing significant amounts of data (when space is marked as Available to the Root space tree).
    ShrinkDatabasePeriodically = 0x8000, // Periodically try to trim the database.
    ShrinkDatabaseTrim = 0x1, // DEPRECATED: Deprecated value for JET_bitShrinkDatabaseOn; Will be removed!
    ReplayReplicatedLogFiles = 0x00000001, // OBSOLETE and UNSUPPORTED, current log shipping implementations use JET_bitRecoveryWithoutUndo.
    ReplayIgnoreMissingDB = 0x00000004, // Ignore missing databases during recovery. This is a very dangerous option and may irrevocably produce an inconsistent database if improperly used. Normal ESE usage does not typically require this dangerous option.
    RecoveryWithoutUndo = 0x00000008, // perform recovery, but halt at the Undo phase
    TruncateLogsAfterRecovery = 0x00000010, // on successful soft recovery, truncate log files
    ReplayMissingMapEntryDB = 0x00000020, // missing database map entry default to same location
    LogStreamMustExist = 0x00000040, // transaction logs must exist in the logfile directory (ie. cannot auto-start a new log stream)
    ReplayIgnoreLostLogs = 0x00000080, // ignore logs lost from the end of the log stream
    AllowMissingCurrentLog = 0x00000100, // this allows JetInitX() to ignore the fact that we are missing edb.jtx|log and edbtmp.jtx|log
    AllowSoftRecoveryOnBackup = 0x00000200, // this allows JetInitX() to perform soft recovery on a backed up database, essentially implementing hard recovery via JetInitX()
    SkipLostLogsEvent = 0x00000400, // this supresses the event for lost committed logs for HA incremental reseed V1
    ExternalRecoveryControl = 0x00000800, // this for absolute control of the recovery process via invoking a callback to be made for all significant state decisions during recovery
    KeepDbAttachedAtEndOfRecovery = 0x00001000, // this allows db to remain attached at the end of recovery (for faster transition to running state)
    ReplayIgnoreLogRecordsBeforeMinRequiredLog = 0x00002000, // Ignore log records before the min required log for an attached database.
    ReplayInferCheckpointFromRstmapDbs = 0x00004000, // When no checkpoint file is present use databases in restore-map to infer checkpoint instead of starting from oldest log.
    RestoreMapIgnoreWhenMissing = 0x00000001, // Ignore missing database when replaying an attach or create database during recovery
    RestoreMapFailWhenMissing = 0x00000002, // Fail early on a missing database when replaying an attach or create database during recovery
    RestoreMapOverwriteOnCreate = 0x00000004, // Overwrite existing database when replaying a create database during recovery
    TermComplete = 0x00000001,
    TermAbrupt = 0x00000002,
    TermStopBackup = 0x00000004,
    TermDirty = 0x00000008,
    IdleFlushBuffers = 0x00000001,
    IdleCompact = 0x00000002,
    IdleStatus = 0x00000004,
    IdleVersionStoreTest = 0x00000008, // INTERNAL USE ONLY. call version store consistency check
    IdleCompactAsync = 0x00000010,
    IdleAvailBuffersStatus = 0x00000020, // Returns JET_wrnIdleFull when database cache available buffers is less than the JET_paramStartFlushThreshold setting.
    IdleWaitForAsyncActivity = 0x00000040, // Waits for all async activity to quiesce. Returns JET_wrnRemainingVersions if there are still pending version store buckets.
    ForceSessionClosed = 0x00000001,
    DbReadOnly = 0x00000001,
    DbExclusive = 0x00000002, // multiple opens allowed
    DbSingleExclusive = 0x00000002, // NOT CURRENTLY IMPLEMENTED - currently maps to JET_bitDbExclusive
    DbDeleteCorruptIndexes = 0x00000010, // delete indexes possibly corrupted by NT version upgrade
    DbRebuildCorruptIndexes = 0x00000020, // NOT CURRENTLY IMPLEMENTED - recreate indexes possibly corrupted by NT version upgrade
    DbDeleteUnicodeIndexes = 0x00000400, // delete all indexes with unicode columns
    DbUpgrade = 0x00000200,
    DbEnableBackgroundMaintenance = 0x00000800, // the database engine will initiate automatic background database maintenance
    DbPurgeCacheOnAttach = 0x00001000, // used to ensure any kept alive cache is purged for this DB before attach
    ForceDetach = 0x00000001,
    DbRecoveryOff = 0x00000008, // disable logging/recovery for this database
    DbVersioningOff = 0x00000040, // INTERNAL USE ONLY
    DbShadowingOff = 0x00000080, // disable catalog shadowing
    DbCreateStreamingFile = 0x00000100, // create streaming file with same name as db
    DbOverwriteExisting = 0x00000200, // overwrite existing database with same name
    BackupIncremental = 0x00000001,
    KeepOldLogs = 0x00000002,
    BackupAtomic = 0x00000004,
    BackupFullWithAllLogs = 0x00000008,
    BackupSnapshot = 0x00000010,
    BackupSurrogate = 0x00000020,
    InternalCopy = 0x00000040,
    BackupEndNormal = 0x0001,
    BackupEndAbort = 0x0002,
    BackupTruncateDone = 0x0100,
    BackupNoDbHeaderUpdate = 0x0200,
    TableCreateFixedDDL = 0x00000001, // DDL is fixed
    TableCreateTemplateTable = 0x00000002, // DDL is inheritable (implies FixedDDL)
    TableCreateNoFixedVarColumnsInDerivedTables = 0x00000004,
    TableCreateImmutableStructure = 0x00000008, // Do not write to the input structures. Additionally, do not return any auto-opened tableid.
    TableCreateSystemTable = INT_MIN, // INTERNAL USE ONLY
    ColumnFixed = 0x00000001,
    ColumnTagged = 0x00000002,
    ColumnNotNULL = 0x00000004,
    ColumnVersion = 0x00000008,
    ColumnAutoincrement = 0x00000010,
    ColumnUpdatable = 0x00000020, // JetGetColumnInfo only
    ColumnTTKey = 0x00000040, // JetOpenTempTable only
    ColumnTTDescending = 0x00000080, // JetOpenTempTable only
    ColumnMultiValued = 0x00000400,
    ColumnEscrowUpdate = 0x00000800, // escrow updated, supported coltyps are long and longlong
    ColumnUnversioned = 0x00001000, // for add column only - add column unversioned
    ColumnMaybeNull = 0x00002000, // for retrieve column info of outer join where no match from the inner table
    ColumnFinalize = 0x00004000, // DEPRECATED / Not Fully Implemented: use JET_bitColumnDeleteOnZero instead.
    ColumnUserDefinedDefault = 0x00008000, // default value from a user-provided callback
    ColumnRenameConvertToPrimaryIndexPlaceholder = 0x00010000, // FOR JetRenameColumn() ONLY: rename and convert to primary index placeholder (ie. no longer part of primary index ecxept as a placeholder)
    ColumnDeleteOnZero = 0x00020000, // When the escrow-update column reaches a value of zero (after all versions are resolve), the record will be deleted. A common use for a column that can be finalized is to use it as a reference count field, and when the field reaches zero the record gets deleted. A Delete-on-zero column must be an escrow update / JET_bitColumnEscrowUpdate column. JET_bitColumnDeleteOnZero cannot be used with JET_bitColumnFinalize. JET_bitColumnDeleteOnZero cannot be used with user defined default columns.
    ColumnVariable = 0x00040000, // make column a variable length column
    ColumnCompressed = 0x00080000, // data in the column can be compressed
    ColumnEncrypted = 0x00100000, // data in the column is encrypted
    DeleteColumnIgnoreTemplateColumns = 0x00000001, // for derived tables, don't bother looking in template columns
    MoveFirst = 0x00000000,
    MoveBeforeFirst = 0x00000001, // unsupported -- DO NOT USE
    NoMove = 0x00000002,
    NewKey = 0x00000001,
    StrLimit = 0x00000002,
    SubStrLimit = 0x00000004,
    NormalizedKey = 0x00000008,
    KeyDataZeroLength = 0x00000010,
    KeyOverridePrimaryIndexPlaceholder = 0x00000020,
    FullColumnStartLimit = 0x00000100,
    FullColumnEndLimit = 0x00000200,
    PartialColumnStartLimit = 0x00000400,
    PartialColumnEndLimit = 0x00000800,
    RangeInclusive = 0x00000001,
    RangeUpperLimit = 0x00000002,
    RangeInstantDuration = 0x00000004,
    RangeRemove = 0x00000008,
    ReadLock = 0x00000001,
    WriteLock = 0x00000002,
    MoveKeyNE = 0x00000001,
    SeekEQ = 0x00000001,
    SeekLT = 0x00000002,
    SeekLE = 0x00000004,
    SeekGE = 0x00000008,
    SeekGT = 0x00000010,
    SetIndexRange = 0x00000020,
    CheckUniqueness = 0x00000040, // to be used with JET_bitSeekEQ only, returns JET_wrnUniqueKey if seek lands on a key which has no dupes
    BookmarkPermitVirtualCurrency = 0x00000001, // place cursor on relative position in index if specified bookmark no longer exists
    IndexColumnMustBeNull = 0x00000001,
    IndexColumnMustBeNonNull = 0x00000002,
    RecordInIndex = 0x00000001,
    RecordNotInIndex = 0x00000002,
    IndexUnique = 0x00000001,
    IndexPrimary = 0x00000002,
    IndexDisallowNull = 0x00000004,
    IndexIgnoreNull = 0x00000008,
    IndexClustered40 = 0x00000010, // for backward compatibility
    IndexIgnoreAnyNull = 0x00000020,
    IndexIgnoreFirstNull = 0x00000040,
    IndexLazyFlush = 0x00000080,
    IndexEmpty = 0x00000100, // don't attempt to build index, because all entries would evaluate to NULL (MUST also specify JET_bitIgnoreAnyNull)
    IndexUnversioned = 0x00000200,
    IndexSortNullsHigh = 0x00000400, // NULL sorts after data for all columns in the index
    IndexUnicode = 0x00000800, // LCID field of JET_INDEXCREATE actually points to a JET_UNICODEINDEX struct to allow user-defined LCMapString() flags
    IndexTuples = 0x00001000, // index on substring tuples (text columns only)
    IndexTupleLimits = 0x00002000, // cbVarSegMac field of JET_INDEXCREATE actually points to a JET_TUPLELIMITS struct to allow custom tuple index limits (implies JET_bitIndexTuples)
    IndexCrossProduct = 0x00004000, // index over multiple multi-valued columns has full cross product
    IndexKeyMost = 0x00008000, // custom index key size set instead of default of 255 bytes
    IndexDisallowTruncation = 0x00010000, // fail update rather than truncate index keys
    IndexNestedTable = 0x00020000, // index over multiple multi-valued columns but only with values of same itagSequence
    IndexDotNetGuid = 0x00040000, // index over GUID column according to .Net GUID sort order
    IndexImmutableStructure = 0x00080000, // Do not write to the input structures during a JetCreateIndexN call.
    KeyAscending = 0x00000000,
    KeyDescending = 0x00000001,
    TableDenyWrite = 0x00000001,
    TableDenyRead = 0x00000002,
    TableReadOnly = 0x00000004,
    TableUpdatable = 0x00000008,
    TablePermitDDL = 0x00000010, // override table flagged as FixedDDL (must be used with DenyRead)
    TableNoCache = 0x00000020, // don't cache the pages for this table
    TablePreread = 0x00000040, // assume the table is probably not in the buffer cache
    TableOpportuneRead = 0x00000080, // attempt to opportunely read physically adjacent leaf pages using larger physical IOs
    TableAllowOutOfDate = 0x00000100, // allow opening with indexes using out-of-date (but valid) sort versions
    TableSequential = 0x00008000, // assume the table will be scanned sequentially
    TableTryPurgeOnClose = 0x01000000, // INTERNAL USE ONLY: attempt to cleanup resources when table is closed
    TableDelete = 0x10000000, // INTERNAL USE ONLY
    TableCreate = 0x20000000, // INTERNAL USE ONLY
    TableClassMask = 0x001F0000, // table stats class mask
    TableClassNone = 0x00000000, // table belongs to no stats class (default)
    TableClass1 = 0x00010000, // table belongs to stats class 1
    TableClass2 = 0x00020000, // table belongs to stats class 2
    TableClass3 = 0x00030000, // table belongs to stats class 3
    TableClass4 = 0x00040000, // table belongs to stats class 4
    TableClass5 = 0x00050000, // table belongs to stats class 5
    TableClass6 = 0x00060000, // table belongs to stats class 6
    TableClass7 = 0x00070000, // table belongs to stats class 7
    TableClass8 = 0x00080000, // table belongs to stats class 8
    TableClass9 = 0x00090000, // table belongs to stats class 9
    TableClass10 = 0x000A0000, // table belongs to stats class 10
    TableClass11 = 0x000B0000, // table belongs to stats class 11
    TableClass12 = 0x000C0000, // table belongs to stats class 12
    TableClass13 = 0x000D0000, // table belongs to stats class 13
    TableClass14 = 0x000E0000, // table belongs to stats class 14
    TableClass15 = 0x000F0000, // table belongs to stats class 15
    TableClass16 = 0x00100000, // table belongs to stats class 16
    TableClass17 = 0x00110000, // table belongs to stats class 17
    TableClass18 = 0x00120000, // table belongs to stats class 18
    TableClass19 = 0x00130000, // table belongs to stats class 19
    TableClass20 = 0x00140000, // table belongs to stats class 20
    TableClass21 = 0x00150000, // table belongs to stats class 21
    TableClass22 = 0x00160000, // table belongs to stats class 22
    TableClass23 = 0x00170000, // table belongs to stats class 23
    TableClass24 = 0x00180000, // table belongs to stats class 24
    TableClass25 = 0x00190000, // table belongs to stats class 25
    TableClass26 = 0x001A0000, // table belongs to stats class 26
    TableClass27 = 0x001B0000, // table belongs to stats class 27
    TableClass28 = 0x001C0000, // table belongs to stats class 28
    TableClass29 = 0x001D0000, // table belongs to stats class 29
    TableClass30 = 0x001E0000, // table belongs to stats class 30
    TableClass31 = 0x001F0000, // table belongs to stats class 31
    LSReset = 0x00000001, // reset LS value
    LSCursor = 0x00000002, // set/retrieve LS of table cursor
    LSTable = 0x00000004, // set/retrieve LS of table
    PrereadForward = 0x00000001, // Hint that the sequential traversal will be in the forward direction
    PrereadBackward = 0x00000002, // Hint that the sequential traversal will be in the backward direction
    PrereadFirstPage = 0x00000004, // Only first page of long values should be preread
    PrereadNormalizedKey = 0x00000008, // Normalized key/bookmark provided instead of column value
    TTIndexed = 0x00000001, // Allow seek
    TTUnique = 0x00000002, // Remove duplicates
    TTUpdatable = 0x00000004, // Allow updates
    TTScrollable = 0x00000008, // Allow backwards scrolling
    TTSortNullsHigh = 0x00000010, // NULL sorts after data for all columns in the index
    TTForceMaterialization = 0x00000020, // Forces temp. table to be materialized into a btree (allows for duplicate detection)
    TTForwardOnly = 0x00000040, // Prevents temp. table from being materialized into a btree (and enables duplicate keys)
    TTIntrinsicLVsOnly = 0x00000080, // permit only intrinsic LV's (so materialisation is not required simply because a TT has an LV column)
    TTDotNetGuid = 0x00000100, // sort all JET_coltypGUID columns according to .Net Guid sort order
    SetAppendLV = 0x00000001,
    SetOverwriteLV = 0x00000004, // overwrite JET_coltypLong* byte range
    SetSizeLV = 0x00000008, // set JET_coltypLong* size
    SetZeroLength = 0x00000020,
    SetSeparateLV = 0x00000040, // force LV separation
    SetUniqueMultiValues = 0x00000080, // prevent duplicate multi-values
    SetUniqueNormalizedMultiValues = 0x00000100, // prevent duplicate multi-values, normalizing all data before performing comparisons
    SetRevertToDefaultValue = 0x00000200, // if setting last tagged instance to NULL, revert to default value instead if one exists
    SetIntrinsicLV = 0x00000400, // store whole LV in record without bursting or return an error
    SetUncompressed = 0x00010000, // don't attempt compression when storing the data
    SetCompressed = 0x00020000, // attempt compression when storing the data
    SetContiguousLV = 0x00040000, // Allocates the long-value across contiguous pages (at potentialy space saving costs) for better IO behavior. Valid only with JET_bitSetSeparateLV. Invalid (or not implemented) with certain long-value operations such as replace, and certain column options such as compression. Use across many varying LVs sizes may cause space fragmentation / allocation issues.
    SpaceHintsUtilizeParentSpace = 0x00000001, // This changes the internal allocation policy to get space hierarchically from a B-Tree's immediate parent.
    CreateHintAppendSequential = 0x00000002, // This bit will enable Append split behavior to grow according to the growth dynamics of the table (set by cbMinExtent, ulGrowth, cbMaxExtent).
    CreateHintHotpointSequential = 0x00000004, // This bit will enable Hotpoint split behavior to grow according to the growth dynamics of the table (set by cbMinExtent, ulGrowth, cbMaxExtent).
    RetrieveHintReserve1 = 0x00000008, // Reserved and ignored
    RetrieveHintTableScanForward = 0x00000010, // By setting this the client indicates that forward sequential scan is the predominant usage pattern of this table (causing B+ Tree defrag to be auto-triggered to clean it up if fragmented).
    RetrieveHintTableScanBackward = 0x00000020, // By setting this the client indicates that backwards sequential scan is the predominant usage pattern of this table (causing B+ Tree defrag to be auto-triggered to clean it up if fragmented).
    RetrieveHintReserve2 = 0x00000040, // Reserved and ignored
    RetrieveHintReserve3 = 0x00000080, // Reserved and ignored
    DeleteHintTableSequential = 0x00000100, // This means that the application expects this table to be cleaned up in-order sequentially (from lowest key to highest key)
    SpaceHintsUtilizeExactExtents = 0x00000200, // This changes the internal allocation policy to always allocate extents of the size requested by the space hints.
    UpdateCheckESE97Compatibility = 0x00000001, // check whether record fits if represented in ESE97 database format
    UpdateNoVersion = 0x00000002, // do not create rollback or versioning information for update
    EscrowNoRollback = 0x0001,
    RetrieveCopy = 0x00000001,
    RetrieveFromIndex = 0x00000002,
    RetrieveFromPrimaryBookmark = 0x00000004,
    RetrieveTag = 0x00000008,
    RetrieveNull = 0x00000010, // for columnid 0 only
    RetrieveIgnoreDefault = 0x00000020, // for columnid 0 only
    RetrieveLongId = 0x00000040,
    RetrieveLongValueRefCount = 0x00000080, // for testing use only
    RetrieveTuple = 0x00000800, // retrieve tuple fragment from index
    RetrievePageNumber = 0x00001000, // page number list for column
    RetrieveCopyIntrinsic = 0x00002000, // retrieves size of data that can be added to a record before offloading LONG columns.  Fixed sized columns return 0 or column size.
    RetrievePrereadOnly = 0x00004000,
    RetrievePrereadMany = 0x00008000,
    RetrievePhysicalSize = 0x00010000, // retrieves compressed size only in cbActual; no data is retrieved
    RetrieveAsRefIfNotInRecord = 0x00020000, // Retrieves the column value as a reference if it is not in the record.
    ZeroLength = 0x00000001,
    EnumerateLocal = 0x00010000,
    EnumeratePresenceOnly = 0x00020000,
    EnumerateTaggedOnly = 0x00040000,
    EnumerateCompressOutput = 0x00080000,
    EnumerateIgnoreUserDefinedDefault = 0x00100000,
    EnumerateInRecordOnly = 0x00200000,
    EnumerateAsRefIfNotInRecord = 0x00400000, // Retrieves the column value as a reference if it is not in the record.
    StreamForward = 0x00000001, // Stream records in ascending key order.
    StreamBackward = 0x00000002, // Stream records in descending key order.
    StreamColumnReferences = 0x00000004, // Stream column values as column references when not in the record.
    RecordSizeInCopyBuffer = 0x00000001, // use record in copy buffer
    RecordSizeRunningTotal = 0x00000002, // increment totals in output buffer instead of setting them
    RecordSizeLocal = 0x00000004, // ignore Long Values (and other data otherwise not in the same page as the record)
    RecordSizeIncludeDefaultValues = 0x00000008, // compute size of default-valued columns (CURRENTLY UNSUPPORTED)
    RecordSizeSecondaryIndexKeyOnly = 0x00000010, // compute size of secondary index key instead of record size (CURRENTLY UNSUPPORTED)
    RecordSizeIntrinsicPhysicalOnly = 0x00000020, // only get physical size for intrinsic columns (cheaper)
    RecordSizeExtrinsicLogicalOnly = 0x00000040, // only get logical size for extrinsic columns (cheaper)
    TransactionReadOnly = 0x00000001, // transaction will not modify the database
    DistributedTransaction = 0x00000002, // transaction will require two-phase commit
    CommitLazyFlush = 0x00000001, // lazy flush log buffers.
    WaitLastLevel0Commit = 0x00000002, // wait for last level 0 commit record flushed
    WaitAllLevel0Commit = 0x00000008, // wait for all level 0 commits to be flushed
    ForceNewLog = 0x00000010,
    CommitRedoCallback = 0x00000020,
    CommitFlush_OLD = 0x00000001, // commit and flush page buffers.
    CommitLazyFlush_OLD = 0x00000004, // lazy flush log buffers.
    WaitLastLevel0Commit_OLD = 0x00000010, // wait for last level 0 commit record flushed
    RollbackAll = 0x00000001,
    RollbackRedoCallback = 0x00000020,
    IncrementalSnapshot = 0x00000001, // bit 0: full (0) or incremental (1) snapshot
    CopySnapshot = 0x00000002, // bit 1: normal (0) or copy (1) snapshot
    ContinueAfterThaw = 0x00000004, // bit 2: end on thaw (0) or wait for [truncate +] end snapshot
    ExplicitPrepare = 0x00000008, // bit 3: all instaces prepared by default (0) or no instance prepared by default (1)
    AllDatabasesSnapshot = 0x00000001, // bit 0: there are detached dbs in the instance (i.e. can't truncate logs)
    AbortSnapshot = 0x00000001, // snapshot process failed
    ShadowLogEmitFirstCall = 0x00000001, // the very first emit has only this bit set, log data will likely follow next
    ShadowLogEmitLastCall = 0x00000002, // the very last emit has only this bit set, no more log data will follow
    ShadowLogEmitCancel = 0x00000004, // future: user requested this be cancelled via resetting the JET_param to NULL
    ShadowLogEmitDataBuffers = 0x00000008, // callback emits some portion of the log buffer and position in log
    ShadowLogEmitLogComplete = 0x00000010, // callback emits signal that the current log file is completed
    DeleteAllExistingLogs = 0x00000001, // Delete all the existing log files at the end of revert.
    PageInfoNoStructureChecksum = 0x00000001, // Do not compute structure checksum
    TestUninitShrunkPageImage = 0x00000001,
    PatchingCorruptPage = 0x00000002,
    EndDatabaseIncrementalReseedCancel = 0x00000001, // Stop an incremental reseed operation prematurely for any (failing) reason.  Database will be left in inconsistent JET_dbstateIncrementalReseedInProgress state.
    CompactStats = 0x00000020, // Dump off-line compaction stats (only when progress meter also specified)
    CompactRepair = 0x00000040, // Don't preread and ignore duplicate keys
    CompactPreserveOriginal = 0x00000100, // Preserve original database
    ResizeDatabaseOnlyGrow = 0x00000001, // Only grow the database. If the resize call would shrink the database, do nothing.
    ResizeDatabaseOnlyShrink = 0x00000002, // Only shrink the database. If the resize call would grow the database, do nothing. The file may end up smaller than requested.
    StopServiceAll = 0x00000000, // Stops all ESE services for the specified instance.
    StopServiceBackgroundUserTasks = 0x00000002, // Stops restartable client specificed background maintenance tasks (B+ Tree Defrag for example).
    StopServiceQuiesceCaches = 0x00000004, // Quiesces all dirty caches to disk. Asynchronous. Cancellable.
    StopServiceResume = INT_MIN, // Resumes previously issued StopService operations, i.e. "restarts service".  Can be combined with above grbits to Resume specific services, or with JET_bitStopServiceAll to Resume all previously stopped services.
    StopServiceStopAndEmitLog = 0x00000008, // Stop any further logging and emit last chunk of log.
    StageTestEnvLocalMode = 0x04,
    StageTestEnvAlphaMode = 0x10,
    StageTestEnvBetaMode = 0x40,
    StageSelfhostLocalMode = 0x0400,
    StageSelfhostAlphaMode = 0x1000,
    StageSelfhostBetaMode = 0x4000,
    StageProdLocalMode = 0x040000,
    StageProdAlphaMode = 0x100000,
    StageProdBetaMode = 0x400000,
    ShrinkDatabaseEofOnAttach = 0x00000001, // Resizes the database file during its attachment.
    ShrinkDatabaseFullCategorizationOnAttach = 0x00000002, // Enables full space categorization when shrinking the database
    ShrinkDatabaseDontMoveRootsOnAttach = 0x00000004, // Disable root moves when shrinking the database
    ShrinkDatabaseDontTruncateLeakedPagesOnAttach = 0x00000008, // Disable truncating leaked pages when shrinking the database
    ShrinkDatabaseDontTruncateIndeterminatePagesOnAttach = 0x00000010, // Disable truncating indeterminate/uncategorized pages when
    DumpMinimum = 0x00000001,
    DumpMaximum = 0x00000002,
    DumpCacheMinimum = 0x00000004,
    DumpCacheMaximum = 0x00000008,
    DumpCacheIncludeDirtyPages = 0x00000010,
    DumpCacheIncludeCachedPages = 0x00000020,
    DumpCacheIncludeCorruptedPages = 0x00000040,
    DumpCacheNoDecommit = 0x00000080,
    DumpUnitTest = INT_MIN,
    InjectionProbabilityPct = 0x00000001, // default, with 100% ulProbability.
    InjectionProbabilityCount = 0x00000002, // one shot on nth (ulProbability) evaluation.
    InjectionProbabilityPermanent = 0x00000004, // same as one shot, but permanent after fire (must be OR'd with JET_bitInjectionProbabilityCount).
    InjectionProbabilityFailUntil = 0x00000008, // same as one shot, but fails until fire (must be OR'd with JET_bitInjectionProbabilityCount).
    InjectionProbabilitySuppress = 0x40000000, // removes injection temporarily
    InjectionProbabilityCleanup = INT_MIN, // removes injection entry for the ID.
    TestHookEvictDataByPgno = 0x00000001, // Specifies that we are evicting data from the database cache, specified by pgno.
    TestHookCorruptDatabaseFile = INT_MIN, // Use .CorruptDatabaseFile
    TestHookCorruptDatabasePageImage = 0x40000000, // Use .CorruptDatabasePageImage
    TestHookCorruptPageChksumRand = 0x00000001, // usable with ...CorruptDatabase*
    TestHookCorruptPageChksumSafe = 0x00000002, // usable with ...CorruptDatabase*
    TestHookCorruptPageSingleFld = 0x00000004, // usable with ...CorruptDatabase*
    TestHookCorruptPageRemoveNode = 0x00000008, // usable with ...CorruptDatabase*
    TestHookCorruptPageDbtimeDelta = 0x00000010, // usable with ...CorruptDatabase*
    TestHookCorruptNodePrefix = 0x00000020, // usable with ...CorruptDatabase*
    TestHookCorruptNodeSuffix = 0x00000040, // usable with ...CorruptDatabase*
    TestHookCorruptSizeLargerThanNode = 0x00010000, // adds a cb that is just larger than the node / line.cb size.
    TestHookCorruptSizeShortWrapSmall = 0x00020000, // adds 0x8000 to the cb.
    TestHookCorruptSizeShortWrapLarge = 0x00040000, // adds 0xF000 to the cb.
    TestHookCorruptLeaveChecksum = 0x01000000, // usable with ...CorruptDatabase*
    AlterDbFileHdrAddField = 0x1, // Makes it so the pbField (but only if cbField is 4 or 8 bytes) be interpreted as an long or long long.
};

}
}
}
